library(reticulate)
# load the virtual environment, Jing you may need to run: use_virtualenv('xx')
use_condaenv('C:\\Users\\yuek\\AppData\\Local\\r-miniconda\\envs\\r-reticulate', required=T) #BOX
# load VAE simulation results
setwd('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE')
source_python('readfile.py')
source_python('VAE_function_balanced.py')
setwd('VAEres')
VAE_res = NULL
input=1
input_list = read.table('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/input_arg_balanced.txt', header=T)
n = as.numeric(input_list[input,1])
p = as.numeric(input_list[input,2])
library_scale = as.numeric(input_list[input,3])
theta = as.numeric(input_list[input,4])
option  = input_list[input,5]
z_scale = as.numeric(input_list[input,6])
model_type= input_list[input,7]
print(input_list[input,])
input=2
input_list = read.table('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/input_arg_balanced.txt', header=T)
n = as.numeric(input_list[input,1])
p = as.numeric(input_list[input,2])
library_scale = as.numeric(input_list[input,3])
theta = as.numeric(input_list[input,4])
option  = input_list[input,5]
z_scale = as.numeric(input_list[input,6])
model_type= input_list[input,7]
print(input_list[input,])
true_comp=readfile('', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_comp=readfile('fix_zscale', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_comp=readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_comp=readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_count = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_count.npy')
VAE_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_comp.npy')
naive_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_naive_comp.npy')
VAE_time = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_time.npy')
# the loaded results will be arrays of dimension c(nrep, 1, n, p)
nreps=50
eval_res = sapply(1:nreps, function(i){
c(
eval_frob(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_frob(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(naive_comp[i, 1, , ], true_comp[i, 1, , ]))
})
mean(VAE_time)
eval_res = matrix(rowMeans(eval_res), nrow=1)
colnames(eval_res) = c('frob','l1','shannon', 'simpson', 'KL', 'frob','l1','shannon', 'simpson', 'KL')
if(is.null(VAE_res)){
VAE_res = rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
}else{
VAE_res = rbind(VAE_res,
rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
)
}
eval_res
dim(naive_comp[, 1, , ])
dim(naive_comp[, 1,1 , ])
library(reticulate)
# load the virtual environment, Jing you may need to run: use_virtualenv('xx')
use_condaenv('C:\\Users\\yuek\\AppData\\Local\\r-miniconda\\envs\\r-reticulate', required=T) #BOX
# load VAE simulation results
setwd('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE')
source_python('readfile.py')
source_python('VAE_function_balanced.py')
setwd('VAEres')
VAE_res = NULL
alpha_res = NULL
for (input in 1:4){
input_list = read.table('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/input_arg_balanced.txt', header=T)
n = as.numeric(input_list[input,1])
p = as.numeric(input_list[input,2])
library_scale = as.numeric(input_list[input,3])
theta = as.numeric(input_list[input,4])
option  = input_list[input,5]
z_scale = as.numeric(input_list[input,6])
model_type= input_list[input,7]
print(input_list[input,])
true_comp=readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_count = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_count.npy')
VAE_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_comp.npy')
naive_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_naive_comp.npy')
VAE_time = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_time.npy')
VAE_zi = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_zi.npy')
# the loaded results will be arrays of dimension c(nrep, 1, n, p)
nreps=50
eval_res = sapply(1:nreps, function(i){
c(
eval_frob(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_frob(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(naive_comp[i, 1, , ], true_comp[i, 1, , ]))
})
mean(VAE_time)
eval_res = matrix(rowMeans(eval_res), nrow=1)
colnames(eval_res) = c('frob','l1','shannon', 'simpson', 'KL', 'frob','l1','shannon', 'simpson', 'KL')
## use VAE_zi to get estimate of scaling parameter alpha
## each row should sum to the same value
hat_alpha = rowSums(VAE_zi[,1,1,])
if(is.null(VAE_res)){
VAE_res = rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
alpha_res = data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, mean = mean(hat_alpha), sd = sd(hat_alpha))
}else{
VAE_res = rbind(VAE_res,
rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
)
alpha_res = rbind(alpha_res,
data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, mean = mean(hat_alpha), sd = sd(hat_alpha))
)
}
}
VAE_res
alpha_res
write.table(VAE_res, '\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/VAE_res_out.txt', row.names = F)
write.table(alpha_res, '\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/VAE_alpha_res_out.txt', row.names = F)
print(VAE_res[,c(1:4, 6, 7, 9:14)])
print(VAE_res[,c(1:4, 6, 7, 9:14)])
write.table(VAE_res, '\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/VAE_res_out.txt', row.names = F)
write.table(alpha_res, '\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/VAE_alpha_res_out.txt', row.names = F)
eval_frob
library(kableExtra)
kable()
?kable
cbind(VAE_res[,c(1:4, 6, 7)], round(VAE_res[,c(9:14)], digits = 4))
cbind(VAE_res[,c(1:4, 6, 7)], round(VAE_res[,c(9:14)], digits = 6))
cbind(VAE_res[,c(1:4, 6, 7)], round(VAE_res[,c(9:14)], digits = 8))
VAE_res
kable(VAE_res[,-5]) %>%
kable_styling()
kable(VAE_res[,-5], 'latex') %>%
kable_styling()
VAE_res[,-5]
alpha_res
library(reticulate)
# load the virtual environment, Jing you may need to run: use_virtualenv('xx')
use_condaenv('C:\\Users\\yuek\\AppData\\Local\\r-miniconda\\envs\\r-reticulate', required=T) #BOX
# load VAE simulation results
setwd('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE')
source_python('readfile.py')
source_python('VAE_function_balanced.py')
setwd('VAEres')
VAE_res = NULL
alpha_res = NULL
for (input in 1:6){
input_list = read.table('\\\\fs2-vip-nfs.nfs.biost.priv\\students\\yuek\\Desktop/VAE/input_arg_balanced.txt', header=T)
n = as.numeric(input_list[input,1])
p = as.numeric(input_list[input,2])
library_scale = as.numeric(input_list[input,3])
theta = as.numeric(input_list[input,4])
option  = input_list[input,5]
z_scale = as.numeric(input_list[input,6])
model_type= input_list[input,7]
print(input_list[input,])
true_comp=readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_comp.npy')
true_count = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_true_count.npy')
VAE_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_comp.npy')
naive_comp = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_naive_comp.npy')
VAE_time = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_time.npy')
VAE_zi = readfile('fix_zscale_', n, p, library_scale, theta, option, z_scale, model_type, '_VAE_zi.npy')
# the loaded results will be arrays of dimension c(nrep, 1, n, p)
nreps=50
eval_res = sapply(1:nreps, function(i){
c(
eval_frob(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(VAE_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_frob(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_l1(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_shannon(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_simpson(naive_comp[i, 1, , ], true_comp[i, 1, , ]),
eval_KL(naive_comp[i, 1, , ], true_comp[i, 1, , ]))
})
mean(VAE_time)
eval_res = matrix(rowMeans(eval_res), nrow=1)
colnames(eval_res) = c('frob','l1','shannon', 'simpson', 'KL', 'frob','l1','shannon', 'simpson', 'KL')
## use VAE_zi to get estimate of scaling parameter alpha
## each row should sum to the same value
hat_alpha = rowSums(VAE_zi[,1,1,])
if(is.null(VAE_res)){
VAE_res = rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
alpha_res = data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, mean = mean(hat_alpha), sd = sd(hat_alpha))
}else{
VAE_res = rbind(VAE_res,
rbind(data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = mean(VAE_time), eval_res[1,1:5 , drop=F], mean_sparsity = mean(true_count==0)),
data.frame(method = 'naive',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, time = 0, eval_res[1,6:10 , drop=F], mean_sparsity = mean(true_count==0)))
)
alpha_res = rbind(alpha_res,
data.frame(method = 'VAE',n=n, p=p, distribution = option, theta=theta, z_scale = z_scale, model_type = model_type, mean = mean(hat_alpha), sd = sd(hat_alpha))
)
}
}
print(VAE_res[,c(1:4, 6, 7, 9:14)])
alpha_res
filepath = '\\\\fs2-vip\\students\\yuek\\Desktop\\micro_net' #BOX
setwd(filepath)
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73",  "#0072B2", "#D55E00", "#CC79A7","#F0E442")
# choose_model = c('null1', 'null2', 'alt1', 'alt2')[2]
# n = c(100, 200, 500, 289)[1]
# p = c(200, 127)[1]
# nreps=100
# run_rep = 1:10 # just compute for 10 repetitions
# part = (1:7)[1] # for the 7 methods
part_name = list('1'='ReBoot', '2' = 'SparCC', '3' = 'CCLasso', '4' = 'COAT','5' = 'SPIEC-EASI', '6' = 'gCoda', '7' = 'SPRING')
copula_distr = 'zinegbin'         # for null1.1 and alt1
copula_distr = 'none'             # for alt2; also for null2
target = 'inv' # or 'cov'
copula_distr = 'none'
choose_model = 'alt2'
network_option='erdos_renyi'
network_condition_number = 100
folder_name = 'data/newref2p'
include=10
data = lapply(c(100,200, 500), function(n){
output_plot_all(folder_name,choose_model,n=n, p=200, nreps=200, part_name, copula_distr,network_option, network_condition_number, target)$data
})
#######################################################################
# get ROC summary for alternative models, dist_data files
include = 20
get_summary_roc = function(folder_name, choose_model, n, p, nreps, part, part_name, copula_distr, network_option, network_condition_number){
# all models we compare the inverse cov graph ROC
# to have an 'averaged' ROC curve, we may take average of fp and tp at each grid? (since we are using the same sequence of lambda)
res_for_20 = lapply(1:include, function(run_rep){
load_file = paste0(folder_name, '/', copula_distr,'/', network_option, '/cond_', network_condition_number,'/', choose_model, '/res_n_', n, '_p_', p, '_', choose_model,
'_nreps_', nreps, '_run_rep', run_rep,'_part_', part, '.RData')
#print(load_file)
iferror = tryCatch(load(load_file), error=function(e){
print(load_file)
e}
)
if('simpleError' %in% class(iferror)) return(NULL)
list(n=n, p=p, model = choose_model, method = part_name[[part]],rep=run_rep,
tp = roc$ROC_inv$tp, fp = roc$ROC_inv$fp, auc = roc$ROC_inv$AUC,
tp_cov = roc$ROC_cov$tp, fp_cov = roc$ROC_cov$fp, auc_cov = roc$ROC_cov$AUC, time = roc$time)
})
# average time information
res_for_20 = res_for_20[!sapply(res_for_20, is.null)]
if(length(res_for_20)==0) return(NULL)
ave_time = mean(do.call(c, sapply(res_for_20, `[`, 'time')))
# inv ROC results
tps = sapply(res_for_20, `[`, 'tp')
if(length(unique(sapply(tps, FUN = length)))>1) stop(paste('check lambda sequence, tp not same length across replications: n',n,'p',p, 'part', part))
fps = sapply(res_for_20, `[`, 'fp')
if(length(unique(sapply(fps, FUN = length)))>1) stop(paste('check lambda sequence, fp not same length across replications: n',n,'p',p, 'part', part))
if(is.null(do.call(cbind, tps))){ave_tp<-NA}else{ave_tp = rowMeans(do.call(cbind, tps))}
if(is.null(do.call(cbind, fps))){ave_fp =  NA}else{ave_fp =  rowMeans(do.call(cbind, fps))}
if(is.null(do.call(cbind, sapply(res_for_20, `[`, 'auc')))){ave_auc = NA}else{ave_auc =  mean(do.call(cbind, sapply(res_for_20, `[`, 'auc')))}
ave_res = list(n=n, p=p, model = choose_model, method = part_name[[part]],
ave_tp = ave_tp, ave_fp = ave_fp, ave_auc = ave_auc, ave_time = ave_time)
# cov ROC results
tps_cov = sapply(res_for_20, `[`, 'tp_cov')
if(length(unique(sapply(tps_cov, FUN = length)))>1) stop(paste('check lambda sequence, tp_cov not same length across replications: n',n,'p',p, 'part', part))
fps_cov = sapply(res_for_20, `[`, 'fp_cov')
if(length(unique(sapply(fps_cov, FUN = length)))>1) stop(paste('check lambda sequence, fp_cov not same length across replications: n',n,'p',p, 'part', part))
ave_tp_cov = rowMeans(do.call(cbind, tps_cov))
ave_fp_cov = rowMeans(do.call(cbind, fps_cov))
if(is.null(do.call(cbind, sapply(res_for_20, `[`, 'auc_cov')))){ave_auc_cov = NA}else{ave_auc_cov =  mean(do.call(cbind, sapply(res_for_20, `[`, 'auc_cov')))}
ave_res_cov = list(n=n, p=p, model = choose_model, method = part_name[[part]],
ave_tp = ave_tp_cov, ave_fp = ave_fp_cov, ave_auc = ave_auc_cov, ave_time = ave_time)
return(list(ave_res = ave_res, ave_res_cov = ave_res_cov, res_for_20 = res_for_20))
}
plot_roc = function(roc_res, target){
if(target=='inv'){
tmp1=data.frame(tp = roc_res$ave_res$ave_tp, fp = roc_res$ave_res$ave_fp, group=rep('mean', length(roc_res$ave_res$ave_fp)))
tmp2= do.call(rbind, lapply(1:length(roc_res$res_for_20), function(i)
data.frame(tp = roc_res$res_for_20[[i]]$tp, fp = roc_res$res_for_20[[i]]$fp,
group=rep(as.character(i), length(roc_res$res_for_20[[i]]$fp)))))
}
if(target=='cov'){
tmp1=data.frame(tp = roc_res$ave_res_cov$ave_tp, fp = roc_res$ave_res_cov$ave_fp,
group=rep('mean', length(roc_res$ave_res_cov$ave_fp)))
tmp2= do.call(rbind, lapply(1:length(roc_res$res_for_20), function(i)
data.frame(tp = roc_res$res_for_20[[i]]$tp_cov, fp = roc_res$res_for_20[[i]]$fp_cov,
group=rep(as.character(i), length(roc_res$res_for_20[[i]]$fp_cov)))))
}
tmp = rbind(tmp1, tmp2)
tmp$n = roc_res$ave_res$n[1]
tmp$p = roc_res$ave_res$p[1]
tmp$model = roc_res$ave_res$model[1]
tmp$method = roc_res$ave_res$method[1]
tmp$time = roc_res$ave_res$ave_time
gplot = ggplot(tmp, aes(x=fp, y=tp, group=group, color=group))+
geom_line()+
geom_abline(slope=1, intercept=0,linetype = 3)+
ggtitle(paste('n',tmp$n[1], 'p', tmp$p[1], tmp$model[1], tmp$method[1]))+
xlab('False Positive')+
ylab('True Positive')+
scale_color_manual(values = c('black', rep('grey',10)))+
scale_linetype_manual(values = c(1, rep(4, 10)))+
geom_line(data = tmp[tmp$group=='mean',], aes(x=fp, y=tp))+
theme(legend.position = 'none')
return(list(plot = gplot, data = tmp))
}
# if to plot all methods together:
output_plot_all = function(folder_name, choose_model, n, p, nreps, part_name, copula_distr, network_option, network_condition_number, target){
data = do.call(rbind, lapply(c(1:5,6, 7), function(part){
roc_res = get_summary_roc(folder_name, choose_model, n, p, nreps, part, part_name, copula_distr, network_option, network_condition_number)
if(is.null(roc_res)){NULL}else{plot_roc(roc_res, target)$data}
}))
data$group = factor(data$group, levels = c(1:nreps, 'mean'))
data$method = factor(data$method, levels=do.call(c,part_name))
plot_all = ggplot(data, aes(x=fp, y=tp, group=group, color = group))+
geom_line()+
geom_abline(slope=1, intercept=0,linetype = 3)+
xlab('False Positive')+
ylab('True Positive')+
ggtitle(paste('dist', copula_distr, 'n',data$n[1], 'p', data$p[1], data$model[1]))+
theme(legend.position = 'none')+
scale_color_manual(values=c(rep('grey', 200), 2))+
facet_wrap(~method)
# ggsave(plot_all, filename = paste0('plot/', copula_distr, '_n',data$n[1], 'p', data$p[1], data$model[1],'.png'))
return(list(data= data, plots = plot_all))
}
target = 'inv' # or 'cov'
copula_distr = 'none'
choose_model = 'alt2'
network_option='erdos_renyi'
network_condition_number = 100
folder_name = 'data/newref2p'
data = lapply(c(100,200, 500), function(n){
output_plot_all(folder_name,choose_model,n=n, p=200, nreps=200, part_name, copula_distr,network_option, network_condition_number, target)$data
})
library(ggplot2)
library(RLANG)
library(rlang)
library(ggplot2)
library(ggplot)
library(ggplot2)
ggplot
ggplot2::ggplot()
